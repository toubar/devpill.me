var suggestions=document.getElementById('suggestions'),search=document.getElementById('search');search!==null&&document.addEventListener('keydown',inputFocus);function inputFocus(a){a.ctrlKey&&a.key==='/'&&(a.preventDefault(),search.focus()),a.key==='Escape'&&(search.blur(),suggestions.classList.add('d-none'))}document.addEventListener('click',function(a){var b=suggestions.contains(a.target);b||suggestions.classList.add('d-none')}),document.addEventListener('keydown',suggestionFocus);function suggestionFocus(c){const d=suggestions.classList.contains('d-none');if(d)return;const a=[...suggestions.querySelectorAll('a')];if(a.length===0)return;const b=a.indexOf(document.activeElement);if(c.key==="ArrowUp"){c.preventDefault();const d=b>0?b-1:0;a[d].focus()}else if(c.key==="ArrowDown"){c.preventDefault();const d=b+1<a.length?b+1:b;a[d].focus()}}(function(){var a=new FlexSearch.Document({tokenize:"forward",cache:100,document:{id:'id',store:["href","title","description"],index:["title","description","content"]}});a.add({id:0,href:"/docs/support/donate/",title:"Donations",description:"How to financially support the development of this guide",content:"   I’m trying to gather resources to fund the development of this public good blockchain development guide and so I got my fren Ana Rueda (@ruedart) to create this amazing graphic for the Mirror NFT edition. The funds will go to the continued development of this guide (90%) and to Ana for the creation of the art (10%). I’m open to discussion on how to structure the open collaboration around the guide and to allocating the funds into a community-owned multi-sig. The goal is to use the funds gathered on Mirror, Gitcoin grants round 13 and elsewhere to incentivize developers to create sections through bounty submissions. If this idea doesn’t gather appeal, then I will send the funds to the Gitcoin grants matching round so that other public goods get funded. Links to support the development of the blockchain development guide:\n Mirror NFTs Gitcoin grants (Gitcoin grants round 13 goes from march 9th - 24th, happens recurrently every 3 months) Alternatively you can donate to the devpillme.eth Ethereum address before I setup a multisig and decentralize the guide and its resources  "}).add({id:1,href:"/docs/social-capital/",title:"Social capital",description:"How do you build and leverage human relationships in order to become a better developer?",content:""}).add({id:2,href:"/docs/support/contribute/",title:"Contributions",description:"How to contribute content to this blockchain development guide?",content:"If you want to contribute, please join this Telegram group that I created for collaborators so that we can better coordinate and distribute tasks. Eventually we will migrate to a more suitable Discord/Forum setup.\nThe process to contribute is as follows:\n Consult about contribution on Telegram group Submit issue on the main repo with what needs to be done Fork the repo Create a branch with a descriptive name Write contributions Create pull request to main repo with given branch and reference the issue in the PR message and who has worked on it (for more people if applicable). Notify @dcbuild3r or admins within the Telegram group to review PR, alternatively ping in PR message by tagging.  "}).add({id:3,href:"/docs/mastery/",title:"Mastery",description:"How to achieve mastery within any developer skillset?",content:""}).add({id:4,href:"/docs/getting-a-job/",title:"Getting a job",description:"How to get a job in the crypto/web3 space",content:""}).add({id:5,href:"/docs/cryptography/",title:"Cryptography",description:"Learn the math behind cryptography and how to apply it to building distributed ledger systems and protocols in web3. Zero-knowledge cryptography included.",content:""}).add({id:6,href:"/docs/blockchain-data-analysis/",title:"Blockhain data analysis",description:"How to leverage data science tools in order to extract and display meaningful information from blockchains",content:""}).add({id:7,href:"/docs/protocol-development/",title:"Protocol development",description:"Learn how to design mechanisms and build protocols.",content:""}).add({id:8,href:"/docs/introduction/foreword/",title:"Foreword",description:"What is this devpill.me all about?",content:"Nowadays there are countless well-made resources on how to learn blockchain development of all kinds and with different specializations in mind, however, it is still very hard to get guidance and personalized suggestions based on your interests. I am writing this guide in order to provide an aggregator of all the resources that I\u0026rsquo;ve found over the years, plus give some opinionated commentary on how to approach them and how to use them in order to maximize learning and practical understanding in order to get building cool things in the space as soon as possible.\nThis guide will focus on the Ethereum ecosystem as that\u0026rsquo;s where most developers and applications are. If you are interested in other ecosystems that are non-EVM compatible and are not L2s on Ethereum, then check out their respective documentation or guides written by their developer communities. Examples of other non-EVM compatible blockchains that are popular are Solana (Rust/Anchor), Polkadot (Rust/Substrate), Cosmos, Terra, and others. Most of these blockchains do or will support the EVM stack through various initiatives like Neon EVM (Solana), Moonbeam/Moonriver (Polkadot/Kusama), EVMOS (Cosmos), etc.\nI really want this guide to become a community-sourced public good that everyone will be able to take advantage of. I will do my best to present it to the wider blockchain developer community to get constructive feedback, proofreading help, and insight into how to make it the best available guide available.\n"}).add({id:9,href:"/docs/mev-searcher/",title:"MEV searcher",description:"How to build bots and find MEV opportunities by searching in the dark forest.",content:""}).add({id:10,href:"/docs/defi-development/",title:"DeFi development",description:"How to build Decentralized Finance applications ",content:""}).add({id:11,href:"/docs/introduction/blockchain-development/",title:"What is blockchain development?",description:"What technologies and principles encompass blockchain development?",content:"There are two main categories in my mind, either you build the infrastructure that runs blockchain-based networks or you build applications that run on top of these decentralized and permissionless networks. Of course, this differentiation doesn\u0026rsquo;t encompass all types of development on blockchains, but it is a good way to get started.\nBy blockchain infrastructure, people usually mean client implementations of blockchain protocols that nodes or validators run to keep the chains running. These clients are usually focused on distributed ledger technology, networking, virtual machines, and various other low-level types of engineering. The client is what enforces the rules of the blockchain protocol, runs the consensus mechanism, that executes all transactions in the network and makes sure all nodes are in sync, and more. This is also known as core blockchain development, which is not what most devs picture when thinking about blockchain or web3 development in general. There are various niches within blockchain development itself as well; you can focus on improving execution capabilities with technologies like rollups, validiums, or volitions, you can improve decentralization and security guarantees by innovating on the consensus layer of the protocol, etc.\nThere\u0026rsquo;s also blockchain infrastructure that supports the application layer by providing APIs to access blockchain data like oracles for smart contracts, indexing services for back ends, libraries that allow you to call and listen to smart contract events, decentralized storage services, and more.\nThe most popular type of blockchain development is on top of the application layer. Building decentralized applications (Dapps) can take many different forms, but it usually involves a smart contract and a user interface that interacts with that smart contract and listens to changes in the state of the blockchain. These applications can serve various use cases and can be used to build decentralized financial services, games, and so much more.\nThere are also applications that aggregate data from different smart contracts, transactions, and events on the blockchain to provide useful insight, these apps are mostly centered around data analysis and are not necessarily decentralized, but require an understanding of the underlying blockchain-based technologies.\nIf these concepts are completely foreign to you I suggest reading the how to get started section first, or Google the words you may not understand.\n"}).add({id:12,href:"/docs/security-engineer/",title:"Security engineer",description:"How to audit the security of various smart contracts, mechanisms and protocols. How to build secure systems and test their robustness.",content:""}).add({id:13,href:"/docs/introduction/specializations/",title:"Specializations",description:"What is there to be learned within blockchain development and what categories are out there?",content:"There are many different specializations within blockchain development, each requires a different set of skills, however a general understanding of distributed systems, basic cryptography, and knowing how smart contracts operate is required as a foundation for all of them. In this guide I\u0026rsquo;ll try to provide a general overview of each of them as well as give the best guidance I can provide on the resources learners should prioritize and in which order they should take them. There are many roles that I\u0026rsquo;m not as familiarized with, so feel free to suggest pull requests with changes or DM with suggestions.\n"}).add({id:14,href:"/docs/core-development/",title:"Core development",description:"How to become a protocol engineer on Ethereum and work on client implementations for the consensus and execution layers.",content:""}).add({id:15,href:"/docs/introduction/skill-based/",title:"Skill-based specializations",description:"How to separate specializations according to the skillsets required to fill a specific role.",content:"There are different sets of skills required for different specializations, the technology stack and knowledge needed are determined by the layer and application that you want to target as a developer. I believe that everyone should get a solid general foundation and try out different areas and niches before settling on the main stack they want to focus on. Some people choose specializations according to the end goal that they want to accomplish using blockchain-based technologies, others like myself feel like everything is interesting and can\u0026rsquo;t settle on a single one to specialize in when confronted with an analysis paralysis situation.\nThis guide will cover these main tracks, however anyone is free to submit a pull-request to add more or expand on the already existing ones:\n Frontend development Smart contract development Backend blockchain development Full-stack blockchain development  Coming soon #  Core development Security engineer MEV searcher Protocol development Cryptographer Blockchain data analytics  "}).add({id:16,href:"/docs/introduction/application-based/",title:"Application-based specializations",description:"How to separate specializations according to the types of applications you want build?",content:"Another way to separate types of blockchain development is not based on the underlying tech stack, but on the use case that you are targeting. These are the categories that I believe are the most popular, however, there are many others that I\u0026rsquo;m not covering to keep the scope of this article more manageable.\nComing soon #  DeFi Creator Economy MEV L2s Infrastructure Gaming Privacy Coordination / Public goods  "}).add({id:17,href:"/docs/starknet-development/",title:"Starknet developer",description:"How to build on the Starknet L2? A guide to the Cairo language and the Starknet ecosystem",content:""}).add({id:18,href:"/docs/full-stack-development/",title:"Full-stack development",description:"How to become a full-stack blockchain developer",content:""}).add({id:19,href:"/docs/smart-contract-development/",title:"smart contracts",description:"How to write smart contracts on Ethereum",content:""}).add({id:20,href:"/docs/back-end-development/",title:"Back end development",description:"Back end development in web3",content:""}).add({id:21,href:"/docs/front-end-development/",title:"Front End Development",description:"Front end development in web3",content:""}).add({id:22,href:"/docs/get-started/",title:"Get Started",description:"How to get started with blockchain development",content:""}).add({id:23,href:"/docs/get-started/introduction/",title:"Introduction",description:"What is this devpill.me all about?",content:"No matter if you are a beginner programmer or if you\u0026rsquo;ve been coding for years, this guide will provide resources for all levels of expertise. If there is something that you already know in the specialization roadmaps that I have here, feel free to skip the material or use it as an opportunity to review what you already know and potentially fill in some gaps in your understanding.\nBlockchain development might seem very intimidating at first, there are many moving parts, foundational knowledge from various different fields is required, the technologies are constantly evolving and aren\u0026rsquo;t as mature as in other areas of development such as in the web development space, there is a financial aspect to almost every application as you are programming on top of a value layer, etc. However, it is not as hard as you might think. Once you get familiarized with the basics, understanding everything else that is going on is usually just a matter of applying a general understanding to a specific situation. If you build a strong foundation then it will be much easier to process more complex topics and reason about problems relating to a new subject matter.\nIf you have a background in computer science, mathematics, or any related field, then you will have a much easier time getting started with blockchain development as many foundational concepts are abstractions of algorithms and data structures. If you are a complete beginner then please make sure you take the initial few steps with patience so as to not feel overwhelmed. Once you start familiarizing yourself with the material you will start to feel like it is more manageable.\n"}).add({id:24,href:"/docs/introduction/",title:"Introduction",description:"What is this devpill.me all about?",content:""}).add({id:25,href:"/docs/get-started/general-foundation/",title:"General foundation",description:"Required knowledge to get started building in web3",content:"In order to get started with blockchain development on Ethereum, one must first get started with understanding how blockchains work in order to build a mental model of how each moving piece works and to get an understanding of the design principles which will govern your development experience.\n"}).add({id:26,href:"/docs/support/",title:"Support this guide",description:"How to support devpill.me and its mission?",content:""}).add({id:27,href:"/docs/get-started/blockchains/",title:"Blockchains",description:"What are blockchains and how do they function?",content:"The term blockchain has two different meanings, it can either relate to a data structure or to a computer network.\nA blockchain (data structure) consists of sets of transactions or data bundled inside a container where each container has a cryptographic hash of the data in the previous container (block) within it. If the contents of the previous block change, the hash changes as well and thanks to this feature we can assure that the data hasn\u0026rsquo;t been tampered with. The second consequence of the blockchain data structure is that it is append-only. You can\u0026rsquo;t prepend data to it, nor modify the data already within it, as that would alter the hashes of all the blocks succeeding the ones that have been modified. This is why we call blockchains immutable.\nA blockchain (network) is a network of computers that have a synchronized ledger of transactions that uses the blockchain (data structure) for storing data (usually inside of merkle/verkle trees). The blockchain is powered by miners/validators which operate under a so-called consensus algorithm, this algorithm helps coordinate who produces and organizes blocks as well as indicating which is the longest chain, by updating the head of the blockchain continuously. Blockchains have 3 main properties which they try to optimize for; Security, Decentralization, and Scalability. They achieve security and decentralization through their consensus algorithm where many different parties need to either provide resources mostly in the form of running expensive operations on massive hardware facilities with Proof-of-Work (PoW) or by staking economic resources in the network with Proof-of-Stake (PoS). The more participants and the more distributed the power dynamics among those participants, the more security and decentralization. There are many other features that contribute to decentralization, like client software which is able to be run on consumer hardware so that anyone can synchronize the state of the blockchain in their nodes, minimizing how many transactions you can process per block so as to not make the state of it too big and much more.\n Further reading  In order to understand how blockchains work beyond my simple explanation here read and watch the following resources:\n Blockchain Explained - Investopedia Blockchain 101 - Anders Brownworth But how does Bitcoin actually work? - 3Blue1Brown Optional (cultural significance): Bitcoin whitepaper  "}).add({id:28,href:"/docs/get-started/ethereum/",title:"Ethereum",description:"What is Ethereum and how does it work?",content:"Since this is a guide about blockchain development on Ethereum, it is required to know how the Ethereum blockchain works, and the changes that it will undergo in the future so as to be prepared for what\u0026rsquo;s to come as a developer. If you have done web development before you can think of changes as a new ECMAScript standard, a new browser compile target (ie. WASM), a new engine (V8), etc\u0026hellip; The Ethereum blockchain is constantly evolving and quite a few changes will be put in place in the future before the core technologies of the network will start to ossify.\nA good way to get started with how Ethereum works is to watch Austin Griffith\u0026rsquo;s ETH.BUILD YouTube playlist where he illustrates how various parts of the Ethereum blockchain work.\n\u0026ldquo;In the Ethereum universe, there is a single, canonical computer (called the Ethereum Virtual Machine, or EVM) whose state everyone on the Ethereum network agrees on. Everyone who participates in the Ethereum network (every Ethereum node) keeps a copy of the state of this computer. Additionally, any participant can broadcast a request for this computer to perform arbitrary computation. Whenever such a request is broadcast, other participants on the network verify, validate, and carry out (\u0026ldquo;execute\u0026rdquo;) the computation. This execution causes a state change in the EVM, which is committed and propagated throughout the entire network.\u0026rdquo; (source: ethereum.org documentation)\nIn order to learn the basics of Ethereum, go through the ethereum.org documentation. Here are links for each section:\n Intro to Ethereum Intro to Ether Intro to dapps Web2 vs. Web3 Accounts Transactions Ethereum Virtual Machine (EVM) Gas (skip the Opcodes section, we\u0026rsquo;ll revisit that later) Nodes and clients Networks Consensus mechanisms Governance / EIP process Ethereum roadmap - Endgame  This graphic shows all the different changes which are being implemented to Ethereum in the upcoming years. It\u0026rsquo;s not necessary to understand what this is all about, but it is good to know about. I suggest watching the video resource appended after the graphic to learn more about what these flowcharts mean.\n Further reading  Ethereum Whitepaper Why Proof of Stake - Vitalik Buterin    "}).add({id:29,href:"/docs/get-started/smart-contracts/",title:"Smart contracts",description:"What are smart contracts and how to write your first one.",content:"A smart contract is a program that runs on the Ethereum blockchain. It\u0026rsquo;s a piece of code that has functions and data (state) which resides at a specific address on the Ethereum blockchain.\nSmart contracts are a type of Ethereum account meaning that they have a balance and can send transactions over the network. They are deployed on the network and run as programmed, user accounts (externally-owned accounts, or EOAs) can interact with a smart contract by submitting transactions that interact with functions that are publicly accessible. Smart contracts can be used to define rules which are enforced via code, e.g. a smart contract that allows for two parties to swap their tokens (like Uniswap).\nHow do I create a smart contract? # The most popular smart contract programming language which targets the Ethereum virtual machine is Solidity. It is a high-level language that was influenced by C++, Python, and Javascript and so its syntax looks familiar. Solidity is statically typed, supports inheritance, libraries, user-defined types, and more. Solidity is a compiled language, which means that before having a runnable smart contract, a Solidity program needs to be run through a compiler that generates a low-level interpretation which is called bytecode. Bytecode are instructions that the EVM can understand and execute.\nThere are other languages that can be used to target the EVM like Vyper and Fe that have their pros and cons, however, they don\u0026rsquo;t have as robust development ecosystems and aren\u0026rsquo;t as widely used by projects deployed in production.\nHere\u0026rsquo;s how a simple counter program would look like in Solidity:\n// SPDX-License-Identifier: MIT pragma solidity ^0.8.10; contract Counter { uint public count; // Function to get the current count function get() public view returns (uint) { return count; } // Function to increment count by 1 function inc() public { count += 1; } // Function to decrement count by 1 function dec() public { count -= 1; } }  In the beginning, you declare the version of Solidity you are using the pragma solidity + version keyword. To indicate the creation of a contract you write it using the contract ContractName {} form. Within the contract curly brackets, the logic of the program is declared. We then declare a simple variable with the name count with unsigned integer type (meaning it can only hold positive integers). Afterward, we declare three different functions, one to retrieve the value held inside of the count variable, one to increase the variable\u0026rsquo;s value by one, and the last one to decrement its value. The public keyword specifies that the function can be called by any address on the blockchain (be it a smart contract or a user-owned account). The view modifier specifies that the function doesn\u0026rsquo;t alter the state within the contract (it only reads values already available). The returns keyword is used to specify the type of the object that is returned back by the function, unsigned integer type in the case of the get() function. Everything which is written after a // is considered a comment and is ignored by the Solidity compiler. Comments are used to make the code more readable and manageable, which is especially helpful if you are working with teams or revisit a codebase after some time. It also acts as documentation for what the code it is doing.\nHow do I compile and deploy my first contract? # In order to compile and deploy our first smart contract, we will use the Remix IDE which is a website where we can write smart contracts, compile them and deploy them on a local instance of the EVM. We can also interact with the local deployed smart contract to test out its functionality. To deploy our simple counter contract, go to Remix, add a new file in the contracts directory, name it Counter.sol, and copy-paste the code in the counter example. Now click on the second icon from the top in the selection bar on the left, it is the logo of the Solidity programming language and it symbolizes the Solidity compiler in Remix. In the compiler dropdown select 0.8.10 which is the Solidity version in our smart contract and click \u0026ldquo;Compile Counter.sol\u0026rdquo;. After you have compiled your contract click on the third icon from the top, it should have the \u0026ldquo;Deploy \u0026amp; Run Transactions\u0026rdquo; name. Click \u0026ldquo;Deploy\u0026rdquo;. After you have deployed, you should see a list item with \u0026ldquo;\u0026gt; COUNTER AT 0x\u0026hellip;. (MEMORY). You\u0026rsquo;ve successfully compiled and deployed your first smart contract! Now that you have it deployed, you can interact with it by calling the inc() or dec() functions to increase or decrease the value of the count variable. You can call the get() function to retrieve the value of the count variable.\n   We will go into a lot more depth on how smart contracts are programmed, tested, and deployed in the smart contract development section.\n"}).add({id:30,href:"/docs/get-started/web2/",title:"Web 2.0",description:"Web 2.0 technologies relevant in blockchain development",content:"Although blockchain developers build decentralized applications, the technologies used to build these applications overlap to a big extent. User interfaces for Dapps are hosted on the internet and are built with traditional web technologies. In order to interact with a smart contract, a user needs to submit a request to a server that hosts an application and that application needs to create a transaction, get the signature from a user via a web3 wallet like Metamask, and then submit the transaction to an Ethereum RPC. The transaction then goes to the mempool, gets picked up by a miner (PoW) / validator (PoS), gets executed and included in the blockchain, and the user interface updates once the blockchain emits an event with a successful call of a function inside of a smart contract. This is the usual flow that decentralized applications have.\nAny blockchain developer that wants to build full-stack applications needs to know how the internet and its most important protocols work as well as how to build user interfaces for all the major platforms (web, mobile, etc). You can think of web3 as adding a native value layer to the internet, it also helps with social coordination and resource allocation with the decentralized autonomous organization structure. It is very helpful to know how the web and the existing technologies built on top of it work and understand how crypto and web3 work in order to create better applications.\nI believe that even though you might not work with developing front-ends it is still good to know how they work on a foundational level as in almost all kinds of development you\u0026rsquo;ll interface with the web in some form. A good learning roadmap for the basics of how web technologies work is the roadmap.sh frontend initial steps in the roadmap. It is also a must to learn how to version control your code, Git is the most popular version control and collaboration software along with GitHub / GitLab for hosting repositories and interacting with other coders.\n   Learning resources #  How does the internet work CS50 HTTP lecture (the CS50 course on edX is a great intro into computer science) freeCodeCamp - Here you can learn the basics of how HTML, CSS and JS works. Unless you\u0026rsquo;re planning to write frontend interfaces you won\u0026rsquo;t need it, but it\u0026rsquo;s still good to experiment and learn how it works. Learn Git Branching - Learn how to use the Git version control system. -GitHub Learning Lab - Learn how to use GitHub and manage git repositories within it. -Open-source Computer Science - If you want to deepen your knowledge in CS you can take all of the necessary learning material that would be required at a university completely online and for free.  "}).add({id:31,href:"/docs/get-started/decentralization/",title:"What makes decentralization important?",description:"Values behind blockchain development, crypto and web3.",content:"In the web 2.0 world, we\u0026rsquo;re used to have a main account on platforms like Google and Facebook which we use to log into other services. All of our data is hosted inside of centralized databases and our private information is used in advertising software to sell us products. In exchange for our data, we get free services. These big centralized entities have a lot of power and control over our daily lives through the products we use each and every day. This is the business model which has worked for the past few decades.\nWhen you decentralize the services and become a sovereign user, you can\u0026rsquo;t be de-platformed, censored, or exploited. As long as you have access to a computer and to the internet you can use any application running on a permissionless and decentralized blockchain. Nobody can block access to them fundamentally, because you can always run a node and submit a call a smart contract and submit a transaction in the blockchain network. Decentralized applications are still in their infancy and many technologies are still not mature enough to support mainstream adoption, however, there is a huge demand for these applications and the industry is evolving rapidly.\nIn a web3 world, users own their assets, their money, their identity, and their data. This allows for a better user experience fundamentally, and even practically once these technologies become mature enough to support the masses. You can eventually have applications like decentralized social networks where users own their content, artists and musicians can produce their artwork and sell it as NFTs and get revenue from royalties and better engaging with their audiences, you can have virtual worlds where people own their digital identity, their virtual items, and their land, etc. The possibilities in web3 are growing day by day and I think it is one of the most exciting technologies that humankind has ever devised. It unlocks so much potential.\n"}).add({id:32,href:"/docs/get-started/web3-values/",title:"Web3 values",description:"Values behind blockchain development, crypto and web3.",content:"The web3 movement is one about creating a value layer for the internet where we can setup incentive structures for the betterment of society in order to make a fairer world where access to products and services is openly distributed, permissionless and accessible to everyone on the planet no matter their provenance.\nThere are many good initiatives like Kernel, Gitcoin, GreenPill and many others that try to help educate about and fund the new wave of public goods and inrastructure in order to create a better world. As a blockchain developer, it is good to get a feeling for why these systems are built out in the first place and the values the products and services we create embody so as to not recreate the centralized web2 world we currently have.\nIn order to learn more about web3 values and how we can create a fairer world, go over Kernel\u0026rsquo;s web3 lessons\n"}).add({id:33,href:"/docs/get-started/play-around/",title:"Play around",description:"Explore the realm of possibilities in blockchain development!",content:"Blockchain development might feel overwhelming, and frankly very intimidating when you are starting out. To remedy this feeling, I suggest you look at programming on blockchains like an adventure game. You can explore what is possible, experiment by creating small projects with technologies that you find interesting, looking at what other people are building and interacting with their applications, debate with various people about their favorite applications, technologies and get a feel for how everything works.\nAs you progress through this guide, you\u0026rsquo;ll start going deeper into various different fields. There is a myriad of interesting primitives in web3 and types of applications you could build and so to pick what to specialize in from the get-go is very hard unless you have a clear goal in mind from the get-go which is quite rare. I personally think that trying everything that interests you if at least for a short while can get you a glimpse into that field and give you insight on whether you\u0026rsquo;d like to focus on that particular area. For this I suggest getting into different developer and research groups and talking about how is it like building those things, what are the types of problems you would be working on, how does one get better in that field, what is there to work on, etc. One of my favorite such groups is Newt which is Aave\u0026rsquo;s experimentation branch. Newt is completely community-driven and tries to promote open-source experimentation where the community is welcome to contribute to existing experiments or create their own. Here you can meet like-minded developers, build cool projects, explore different areas of development and different fields within web3 such as DeFi, NFTs, and more. DeveloperDAO and EthernautDAO are also good developer communities where you can search for like-minded individuals and explore the possibilities of what\u0026rsquo;s possible in web3, and potentially even getting full-time job offerings.\n"}).add({id:34,href:"/docs/get-started/connect/",title:"Connect",description:"Meet the people inside of the space, aka the layer 0.",content:"Blockchain development is a fairly new field and so most information about how to build applications in web3 is available on the internet and not in universities and other educational institutions. This might make it a lonely endeavor, but it need not be! There are people all across the world learning how to build cool projects with these technologies and everyone is looking to learn from each other and make friends in the space. As mentioned before, join DAOs and groups like Newt, DeveloperDAO, EthernautDAO, etc, talk about your learning journey on Twitter and try to provide insight into your experience with learning these technologies. You\u0026rsquo;re bound to find like-minded individuals with whom you can share your interests, it helps a lot with learning the material as when you have to explain a complex topic to a person without former knowledge, it forces you to understand your subject very well in order to explain it simply. Pair-programming or pair-learning is also a good way to cement new learnings. Personally, I found that making friends online that are also into blockchain development is what made it the most fun and engaging for me and is helping me stick with the material for longer periods of time than I otherwise would have.\nTwitter is currently the platform where most builders, researchers, and creators share their insights in the realm of blockchain and web3, so it is almost a must if you want to keep up with the newest technologies. I also recommend to not overdoing social media as it can lead to a drastic decrease in productivity. It\u0026rsquo;s a balance that needs to be achieved over time, a good tip is that whenever you want to check Twitter or Discord you have a clear goal in mind, e.g. goal: I want to learn what new gas optimizations have my friends come up with? I also recommend creating lists with different types of people so you can sort by the type of content you want to see (DeFi, NFTs, MEV, smart contracts, frontend, design, etc). Bookmarking is also a good feature if you want to revisit interesting tweets in the future.\nAnother great way to meet devs is to go to hackathons and conferences. If you can afford to go to events then definitely do, however, if you don\u0026rsquo;t have enough funds there are oftentimes grants for first-time attendees through places like PadawanDAO, and others. Usually asking around to volunteer will get you a free entrance and people are usually kind enough to pool funds to sponsor people looking to get into the space that doesn\u0026rsquo;t have the means to afford to travel by themselves. In-person events like hackathons are a great way to develop your skills and meet people. It\u0026rsquo;s where many projects that are popular today were started and the place where founders of projects usually meet for the first time. As for events worth going to in 2022, I suggest Devconnect (Amsterdam), ETHPrague, ETHCC/ETHParis and Devcon (Bogota). Here is a good list with Ethereum-related events in 2022, there are also events on pretty much every continent and there are also small local events that different communities organize, so look for events near you that might be related to blockchain development in some way or start one yourself!\nI also recently started creating a Twitter list with blockchain devs that I think you should follow if you want to learn blockchain development. It is a running list so feel free to DM me devs I should add and I\u0026rsquo;ll consider adding them to the list.\n"}).add({id:35,href:"/docs/get-started/build/",title:"Build",description:"Code, fail, get up, try again, learn, improve, repeat",content:"The next and final step to get started with blockchain development should be obvious by now, it is to actually start building! After you\u0026rsquo;ve gone through the introductory foundational material that I wrote in the sections above you are ready to get going with one of the specializations listed below. If you are not sure which one you\u0026rsquo;re into yet, just go with full-stack blockchain development and you\u0026rsquo;ll get to try a bit of everything! Start writing code, no matter how bad it is, and try to get feedback on it from devs that know more than you do. Go through the roadmap that I have specified below, learn a concept, take notes, build something around it, do some testing and move on. If there is something that catches your attention, then try building something with it and see where it takes you. Your own curiosity and interest are your best friend when learning blockchain development. You should constantly ask yourself why did the thing that I wrote worked and how I could make it better, if you can\u0026rsquo;t come up with an answer you either ask someone for an explanation or for a code review. It is also good to review quality code written by other teams. If you are learning Solidity, for example, the best way to learn advanced Solidity is to read into production codebases like Aave v3, Uniswap v3, Balancer v2, etc. The same principle applies to other categories and specializations as well.\nOnce you build something, share it with the world (unless it\u0026rsquo;s a very profitable MEV bot)! Sharing it on Twitter and different Discords will bring attention to what you\u0026rsquo;re doing and you might get constructive feedback and/or meet new friends that are interested in what you are building. If you are building something more complex, try creating documentation for it or make some useful comments if you expect other people to read your code. It is also great to share code and make it publicly available on hosting platforms like GitHub to build a portfolio of projects which you can showcase in order to show other people when applying for job positions. I\u0026rsquo;ll revisit how to get employment in web3 in a later section.\n"}).add({id:36,href:"/docs/get-started/skill-based-development/",title:"Skill-based development",description:"Values behind blockchain development, crypto and web3.",content:"Now we get down to different specializations, before getting started looking at different paths you can take make sure you\u0026rsquo;ve gone through the Foundational section. I also suggest reading the introduction to each specialization in both the skill-based development and application-based development categories so that you have a better idea of what\u0026rsquo;s out there and what you might find interesting before going deeper into any specifical one. This section will focus on categorizing specializations in blockchain development with regard to the skillsets required within them.\n"}).add({id:37,href:"/docs/front-end-development/introduction/",title:"Introduction",description:"What is front end development?",content:"Front-end (FE) development is probably the easiest once out of all of the ones I\u0026rsquo;ll be listing in my guide. Most of the technology stack blockchain developers use to build user interfaces for their applications overlaps with the traditional web-development infrastructure and so there are is a mature ecosystem of languages, libraries, and APIs you can make use of as a developer to make your life much easier as well as a vast community of developers which maintain codebases, provide support through platforms like StackOverflow and create very well produced tutorials and documentations for learning these established technologies, something which isn\u0026rsquo;t the norm in rapidly emerging and constantly evolving web3 technologies.\nThe key principles of front-development require knowing how to structure and style websites, how to make them dynamic with JavaScript and different frameworks, how to manage state within applications, basic design, how to fetch data from APIs and databases, and how to create good web3 user experiences regarding wallets and the interactions with the smart contract backend of your application. One of the biggest differences in web3 FE development is user-authentication as instead of logging in with your email and password or your Google account, you log in with your wallet using a third-party application like Metamask or WalletConnect and protocols like ENS to display information about the user (provided they have an Ethereum domain). If a smart contract contains a state which represents past interactions with the application by the user, you also need to fetch historical data from the blockchain on-demand or maintain a local database with indexed data which is easily queriable by the FE of the application.\nAs a front-end blockchain developer you need to know what a Contract Application Binary Interface (ABI) is in order to be able to interact with smart contracts on the Ethereum blockchain or on an L2 like Optimism, Arbitrum, Starknet, or ZkSync which are Ethereum-based scaling solutions that we\u0026rsquo;ll cover in the L2 section. You also need to query data from various APIs to accurately display the price of various assets (if applicable), the user\u0026rsquo;s balance of ERC20 tokens or NFTs, and various other data you might need from either the blockchain itself or an external database.\nAnother interesting feature of programming decentralized applications is the need for building applications that are not hosted on a centralized server, to remedy this problem many developers have their web interfaces open-sourced and have many instances of those interfaces on decentralized storage solutions like IPFS, Arweave, and others. In this way, if one of the servers hosting the interface to interact with the smart contracts goes down, users can interact with it from many other different places. It\u0026rsquo;s also amazing that since the functions are able to be called by anyone, users can interact with decentralized applications from completely different frontends as long as they have the ABI, this allows for massive composability which we\u0026rsquo;ll cover a bit later.\nThis roadmap will focus on the frontend technologies that I\u0026rsquo;ve seen are mostly used in blockchain development today. I\u0026rsquo;ve used the roadmap.sh frontend roadmap, a friend\u0026rsquo;s tech stack, and my experience as a reference for creating this specialization. If you are a more experienced reader feel free to suggest pull requests to add/edit/remove content or you can suggest changes by DMing me on Twitter or Telegram (@dcbuild3r).\n"}).add({id:38,href:"/docs/front-end-development/basics/",title:"Basics",description:"The basics of front end web development",content:"The pillars of web development technologies are HyperText Markup Language (HTML), Cascading Style Sheets (CSS), JavaScript (JS), and web application programming interfaces (APIs).\nHTML is the language that is used to structure websites, with HTML you can insert text, images, videos, create different sections for your website, create links to other sites, and more. CSS is a styling language that helps you edit how your HTML elements look, how they are displayed and how they are arranged on your screen. It is also what makes user interfaces responsive for different devices like mobile, tablet, laptop, desktop, and others by providing APIs which dynamically resize your HTML elements based on the width and height of the screen a specific user has. JavaScript is a programming language that makes your HTML elements dynamic, it allows for things like complex animations, dynamic formatting of elements depending on given inputs, state management within your application, much more utility thanks to its programmability, and more. HTML, CSS, and JavaScript are the only 3 technologies that browsers understand, the rest of the technologies mentioned in this specialization end up compiling to an optimized HTML, CSS, and JS bundle which the browser can process and interpret.\nThe best place to learn the basics of web development in my opinion is freeCodeCamp where you can do the lessons in the first two sections named \u0026ldquo;Responsive Web Design\u0026rdquo; and \u0026ldquo;JavaScript Algorithms and Data Structures\u0026rdquo;. It says that each section takes about 300 hours each, but usually, you can do it in much less since it\u0026rsquo;s a conservative estimate. After you\u0026rsquo;ve gone through these two sections and made the initial projects that are required to fulfill them you can move on to learning React. Another great place to learn is the Mozilla developer documentation where you can learn everything about HTML, CSS, JS, Web APIs and their specifications, protocols like HTTP and other web technologies.\n"}).add({id:39,href:"/docs/front-end-development/react/",title:"React",description:"What is React.js and how to build UIs using it.",content:"In modern web development, you\u0026rsquo;ll almost never write vanilla HTML, CSS, and JavaScript to build your websites. Web developers learn a view framework that helps them to better structure their code with components and also optimize the way in which components are rendered and how changes to the state of the application affect what the users see. The most popular web development framework is React with a wide margin compared to Vue.js. React was originally developed by the Facebook team, but was open-sourced early on and now it has thousands of contributors and many full-time maintainers who are constantly pushing the framework forward.\nMost of the user interfaces for blockchain applications are programmed using React and there are many React component libraries that you can reuse from the community to perform common tasks like logging with an Ethereum wallet, switching networks, and also so-called React hooks libraries (i.e. eth-hooks) which let you fetch different data like balance, block number, prices and more.\nI believe that React is best learned from the official documentation, but there are also other resources for people that learn better with video content. Here is a list of React learning resources that I recommend:\n React in 100 Seconds - Fireship React roadmap Official React documentation awesome-react - This GitHub repository aggregates many useful resources for React developers, it has tutorials, tooling, component libraries, frameworks, design patterns, guidelines, and much more. It is a good place to look for inspiration and resources when using React. If you want a paid video course I can recommend either ZTM\u0026rsquo;s React course or Maximilian Schwarzmuller\u0026rsquo;s React course. On Udemy there are sales periods every once in a while which allow you to buy courses for $15 instead of $200, so wait for one of those, never buy for the full price. freeCodeCamp React course on YT  After you feel like you\u0026rsquo;ve understood how React works, you have learned about lifecycle methods, hooks, how to pass down data through props, how to use the Context API, etc. I recommend trying to build the front end of a web3 app like Uniswap or an NFT marketplace like OpenSea. To rapidly prototype the design I recommend using tailwind.css and Chrome browser developer tooling to inspect the styles of the site you\u0026rsquo;re trying to recreate. Also, don\u0026rsquo;t forget to use CSS flexbox/grid where necessary. Try to simulate the data inside of these apps using hardcoded JSON objects.\n"}).add({id:40,href:"/docs/front-end-development/typescript/",title:"Typescript",description:"What is the Typescript programming language and how it differs from Javascript",content:"Typescript is a superset of JavaScript which allows you to statically type JavaScript code. This means that you declare the types of variables (integer, string, \u0026hellip;). It allows for a better developer experience as the Typescript compiler can catch many errors ahead of time since it checks the types of the objects ahead of time. It also allows developers to tap into extra features on top of JavaScript which allows writing more expressive JavaScript. Remember that Typescript cannot be run by the browser and needs a compiler to convert TypeScript code into runnable JavaScript. Typescript is widely used by the web-development community thanks to its features that improve security, readability, allow for a better development experience inside of the IDE with autocompletion, and add cool new syntactic sugar on top of JavaScript.\nI recommend going to the Typescript documentation, it is good to get into the habit of going to official documentation since they are usually the right place to visit if you are learning new technology. Once you have the basics down try building a simple application with it or refactor an existing application in a way that uses the technology that you are learning.\n"}).add({id:41,href:"/docs/front-end-development/nextjs/",title:"NextJS",description:"How to learn the NextJS React framework.",content:"Next.js is a React framework that enables server-side rendering, static site generation, does smart bundling, route pre-fetching, and a lot more. Next.js is able to heavily optimize your websites by only loading what you need on-demand instead of having to load up the entire site at the beginning. It also allows for a much better experience with creating API routes thanks to its file-system routing feature, it optimizes images, it has Typescript support, it helps with i18n API internationalized routing, and a lot more.\nLearning resources:\n Next.js documentation awesome-nextjs  "}).add({id:42,href:"/docs/front-end-development/indexing-querying/",title:"Indexing / Querying",description:"How to fetch meaningful information from a blockchain.",content:"The applications you will be building need to know what is the state of the blockchain so that your users know what is happening and can interact with the application effectively. An example of this is Uniswap\u0026rsquo;s AMM. In order to call the swap function in the smart contracts, you need to know how many tokens you will get back with an X amount of ETH that you put into the contract. In order to display the current price of any asset, your application will either query data from the blockchain directly or it will use an indexing service that has that data already available. These APIs are very useful and are a critical part of any application.\nTheGraph # A very popular service is TheGraph. TheGraph is a decentralized indexing protocol that allows you to query networks like Ethereum, the protocol has an incentive layer that rewards indexers to create APIs for the data you specify. Developers can create so-called subgraphs, which are data APIs that make the data easily accessible through a GraphQL schema. GraphQL is a querying language that is used as an alternative to traditional REST APIs. GraphQL schemas are harder to set up initially, but in turn, they enjoy massive scalability. In order to learn more, check out their documentation. To learn how GraphQL works checkout the official documentation, HowToGraphQL and this YouTube playlist (although it may be a bit outdated by now, better check the documentation).\nNodes # One of the most common ways to query data from the blockchain is by calling RPC endpoints of nodes that are syncing the full-state of the blockchain. A node runs the Ethereum blockchain, has all of its state, and syncs periodically every single time a new block appears. You can run your own node on consumer hardware, but it is unscalable if you want to use those nodes for querying data for massive applications as you\u0026rsquo;d need to build your own DevOps pipelines in order to scale to your needs accordingly. That\u0026rsquo;s why most developers use a third-party node provider like Alchemy or Infura. You can call these APIs by using web3 libraries like ethers.js, web3.js or myriad others. If you have a React front end, I strongly recommend using eth-hooks (can be installed as an npm package), which is built by the scaffold-eth people.\nMoralis # Moralis is a web3 development platform that automates your backend, instead of having to query data from nodes, indexing the data, and creating databases so that you don\u0026rsquo;t need to query the blockchain on every user request, Moralis does it for you. You instantiate a Moralis server that exposes an API to all blockchain data through a REST API to a PostgreSQL database. It also has smart contract alerts, cloud functions, cross-chain user authentication, and more. The only downside of using Moralis is that it\u0026rsquo;s a centralized service provider. It is the easiest way to get a backend for your Dapp going as Moralis has a very simple to use SDK that helps you tap into the APIs offered by their services. It is a great way to get started building backends as most of the heavy lifting is done for you.\nLearning Resourrces #  Moralis documentation Moralis YT channel  "}).add({id:43,href:"/docs/front-end-development/web3-libraries/",title:"Web3 libraries",description:"Libraries to interact with the Ethereum blockchain programatically",content:"Ethers.js is one of the most popular libraries for interacting with the Ethereum Blockchain and its ecosystem. Smart contracts that are deployed on the Ethereum blockchain have functions that can be called externally by any other account on Ethereum, be it an externally owned account (EOA = user wallet) or another smart contract. Many of these functions require certain parameters to be fed into them, they also rely oftentimes on an external state like prices of tokens on the blockchain, balances of the user\u0026rsquo;s wallet, and more. Ethers.js is what allows a user interface to call these functions, users can input certain information in the frontend of your application and that information can be put into the function call of the smart contract, after the transaction is broadcasted the EVM will try to execute that function call and if every check inside of the function doesn\u0026rsquo;t give out any errors it will execute, otherwise, the transaction will revert.\nEthers.js is currently the most popular Ethereum library among developers, but there are alternatives like web3.js, web3.py, Brownie, and many others. The second most popular framework is web3.js and it is the Ethereum JavaScript library that has been around the longest. For a comparison of ethers.js and web3.js read this article written by the Moralis developer team.\nLearning resources #  ethers.js documentation  "}).add({id:44,href:"/docs/front-end-development/design/",title:"Design",description:"How to learn design as a front end developer?",content:"As a front-end developer, you need to focus on how your application looks and how it feels to use it. A big part of that is designed, before building a website you should prototype how you want it to look, design how your users will interact with your application, how will that fit with the use case of your application, and what you want to accomplish with it, how to make it so that your users like using it and more. UI/UX is a specialization of its own, but every single front-end developer should have strong foundations in UI/UX regardless. Most big teams will have designers which will prototype applications using tools like Figma, Framer Motion, and various other tools. As a front-end developer, your task is to turn those designs into functioning code and hook all of the components to the APIs and databases necessary as well as creating the functionality of the application.\nOne of the most popular tools to prototype and design websites is Figma, so every FE developer should know how to use the application.\nLearning resources #  freeCodeCamp Figma YT course  "}).add({id:45,href:"/docs/front-end-development/web3-templates/",title:"Web3 templates",description:"Starting points to create your web3 projects",content:"When you are building web3 applications you usually start with a template. A template is just a group of libraries, pre-built user interfaces, and another tooling that create a favorable environment to build your application. A lot of the initial hard work to set up a project can be reused across projects to save time and effort on building redundant infrastructure. Many web3 templates have support for smart contracts out of the box which is what you\u0026rsquo;ll be interacting with most of the time as a front-end developer. It is good to know the basics of smart contracts and understand how to get a contract factory out of the ABI to call its methods within your user interface. That\u0026rsquo;s the biggest overhead when building in web3 in comparison to being a frontend developer in web2 where you only have to care about fetching data from REST or GraphQL APIs.\nYou can build your own templates depending on your needs, or modify already existing ones. Popular web3 templates include:\n moralis-starters scaffold-eth create-eth-app  "}).add({id:46,href:"/docs/front-end-development/tooling/",title:"Tooling",description:"Which complementary tools will you use as a front end blockchain developer",content:"As a developer, there are many tools you\u0026rsquo;ll use to make building applications easier and more efficient, to collaborate on projects with other people, to manage dependencies, and much more. This is a short section on different tooling you\u0026rsquo;ll find yourself using regularly.\nPackage management # If you\u0026rsquo;ve gotten this far in the front-end specialization you\u0026rsquo;ve certainly had to install packages like React, Next.js, tailwind.css, ethers.js, and many others. The most popular package managers in the JavaScript ecosystem are npm and yarn. Package managers allow you to keep track of which versions of which external code libraries your application uses as well as how the project\u0026rsquo;s code is structured, how to run different tests, how to run your program, and various other miscellaneous tasks.\nAs you build more complex applications it is good to learn the depths of your package manager, how to structure package.json files, how to write scripts that automate the boring stuff, how to set up a CI/CD pipeline (we\u0026rsquo;ll talk about this in a bit), and more.\n Package management basics npm yarn  Styling / Animation # There are many CSS libraries and frameworks which modify the way in which you write CSS. There are libraries that allow you to write CSS within JavaScript, component libraries for React which have a lot of the styling done for you, animation libraries, and more. I\u0026rsquo;ll mention a few of the most popular ones, feel free to suggest changes as I\u0026rsquo;m not an expert in the area.\n styled-components (CSS in JS) Tailwind.css (CSS framework) Framer Motion (Animations framework) Chakra UI (component library) Material UI (component library) Sass (CSS pre-processor) PostCSS (CSS pre-,post-processor) awesome-CSS (CSS learning repo)  Linting / Formatting # A linter is a static code analysis tool used to flag programming errors, bugs, stylistic errors, and suspicious constructs and a code formatter makes sure that the code you write has a homogenous style structure and abides by the formatting rules of a specific programming language (i.e. PEP8 for Python). When you\u0026rsquo;re writing code, it\u0026rsquo;s easy to miss a space, a tab, a colon, an opening or closing bracket, or to write code with bad and inconsistent styling. That\u0026rsquo;s where linters and formatters will come in handy as they automate the task, they can be configured to run on saving and on commit, so that badly styled code never gets into production or into a public repo. The most popular choices are:\n Eslint Prettier  CI/CD # CI/CD stands for continuous integration / continuous deployment, they are a set of tools that allow you to create automatic processes that execute whenever a change is made to the codebase usually hosted on the cloud so that the production servers running your application get automatically updated with the newly pushed code. These actions can also modify and run tests on the code before it gets pushed into production, if tests fail the commit or update will not go through and collaborators will get notified of this. Once projects become bigger and they have big teams of contributors a solid CI/CD pipeline is very important so as to maximize the security and correctness of code being pushed into production. Examples of popular CI/CD tooling are:\n GitHub Actions CircleCi Husky  Testing # A key part of development is mitigating how many bugs are inside of your application. To ensure that the code behaves as it is intended to we write unit tests, integration tests or even end-to-end tests. Each kind of test focuses on a different part of the application lifecycle. Modern tooling like Cypress allows you to simulate all possible states of your application and simulate user flows, you can even record user session tests as if you were recording a real user going through your website. In web3 you will also be doing integration tests for smart contract interaction. You can test smart contracts using libraries like Foundry, Hardhat or Truffle. Most of these tests will be written by a smart contract or full-stack developer, however, as a frontend developer, you need to test how the interactions with the contracts will influence the flow of the user interface of your application. You can write various tests in JavaScript with ethers.js and couple it with Cypress to write complex tests. The web3 app development lifecycle usually goes from locally deployed smart contracts and front-end, to testnets (live network environment but with non-valuable assets), and to mainnet (not necessarily Ethereum mainnet, it can be an L2 like Arbitrum, a sidechain like Polygon PoS, etc). On the smart contract, side development teams hire external security auditors to verify that the contracts are secure to use, we will cover this in-depth in the smart contract development section.\n Cypress Jest Mocha  ENS integration # ENS domains are human-readable domains for Ethereum addresses, the registrar for these domains is fully on-chain and the protocol is decentralizaed and governed by a DAO. ENS domains serve as an on-chain identity mechanism which many Ethereum users use to express themselves on-chain and to display information about themselves through ENS profile metadata containing contact information like email, Twitter, Discord or links to websites, a profile picture (NFT image metadata) and more. As a web3 front end developer you can tap into this registrar and display users' information once they\u0026rsquo;ve connected to your application with their web3 wallet.\nThe best way to get started with ENS is their official documentation, here you can get a general understanding of the ENS protocol. For integrating ENS into your dapp, visit this section. You need to perform 3 steps in order to support ENS within your application:\n Resolve ENS names Support reverse resolution Let users manage their ENS names  If you are interested in how the on-chain parts of ENS work, check out the smart contract development section\n"}).add({id:47,href:"/docs/front-end-development/further-development/",title:"Further learning and development",description:"What to do beyond the contents of this blockchain development guide as a front end developer",content:"By now you have learned a solid technology stack that can enable you to build all kinds of user interfaces for web3 apps. In order to really engrain these technologies, you need to build pet projects or join a team full-time, even if you only know a few of them you can join a team and get upscaled there as your learning will be supercharged by more experienced coworkers that will act as mentors most of the times. The front-end development landscape is constantly evolving new technologies will come and go, it is in your best interest to look at trends in the industry and try adapting them once they are a clear sign of them becoming adopted. You will keep improving your technology stack over time especially as you become more senior and you are able to reason why you want to use one tool over the other and how it fits into the needs of the applications that you are building.\nBuild, Build, Build! Try creating small projects that implement ideas you come up with and practice the technologies you want to master. Also, don\u0026rsquo;t be shy to ask questions to other web3 developers, and form learning groups with your friends, or other industry members.\nAlso, read over the Getting a Job and Mastery sections of this guide to get more insight into soft skills which are useful to learn to grow as a developer.\n"}).add({id:48,href:"/docs/back-end-development/introduction/",title:"Introduction",description:"What is back end development and how to get started",content:"As far as blockchain development goes, most of the logic that traditional applications would consider backend is encapsulated within smart contracts, however, there are also complementary technologies that allow you to query data from blockchains, index the data, create databases so that you have on-demand data from custom APIs, decentralized storage for content, user authentication / DID, etc. I wouldn\u0026rsquo;t consider this its own specialization, but it is a sufficiently unique skill set for me to cover it separately.\nThis image was created by my fren Nader Dabit who is a full-stack blockchain developer that has created many useful guides, some of which I\u0026rsquo;ll feature in the full-stack development section. This web3 stack landscape graphic comes from a recent blog post of his called The complete guide to full-stack web3 development.\n   "}).add({id:49,href:"/docs/back-end-development/file-storage/",title:"Decentralized file storage",description:"How to store files in a decentralized way using networks like IPFS and Arweave",content:"There are many applications that require storing files of all sorts and making them available for your decentralized applications, NFTS for example only have a link to the URI metadata on-chain, and that URI points to a decentralized storage endpoint on IPFS or Arweave. Meaning that all the images and the traits of the NFT are hosted in their file storage networks rather than on the Ethereum mainnet in order to save on costs and allow for higher bandwidth.\nIPFS # IPFS is one of the most popular decentralized file storage solutions out there, there are projects like Filecoin being built on top and many NFT metadata are hosted inside of the network. There are solutions like NFT Storage that make the metadata hosting completely free to upload your NFT metadata on-chain by leveraging their Javascript API.\nArweave # Arweave is another such solution. Arweave is a type of storage that backs data with sustainable and perpetual endowments, allowing users and developers to truly store data forever – for the very first time. As a collectively owned hard drive that never forgets, Arweave allows developers to remember and preserve valuable information, apps, and history indefinitely.\nAn increasingly popular use case of decentralized file storage solutions is web hosting, since we are on a quest to build decentralized applications that are uncensorable, it is good practice to also decentralize the user interface by deploying it on decentralized file storage networks like IPFS and Arweave. This prevents the applications you built from being censored by centralized entities shutting down your deployments on centralized platforms like Vercel, AWS, Azure, or any other. Part of good practices of modern applications is open-sourcing the front end of their applications so that anyone can run them locally and also deploying several other instances to decentralized file storage solutions as well as usually hosting their own front end in a centralized server for added performance.\n"}).add({id:50,href:"/docs/back-end-development/indexing-querying/",title:"Indexing / Querying",description:"How to fetch meaningful information from a blockchain",content:"The applications you will be building need to know what is the state of the blockchain so that your users know what is happening and can interact with the application effectively. An example of this is Uniswap\u0026rsquo;s AMM. In order to call the swap function in the smart contracts, you need to know how many tokens you will get back with an X amount of ETH that you put into the contract. In order to display the current price of any asset, your application will either query data from the blockchain directly or it will use an indexing service that has that data already available. These APIs are very useful and are a critical part of any application.\nTheGraph # A very popular service is TheGraph. TheGraph is a decentralized indexing protocol that allows you to query networks like Ethereum, the protocol has an incentive layer that rewards indexers to create APIs for the data you specify. Developers can create so-called subgraphs, which are data APIs that make the data easily accessible through a GraphQL schema. GraphQL is a querying language that is used as an alternative to traditional REST APIs. GraphQL schemas are harder to set up initially, but in turn, they enjoy massive scalability. In order to learn more, check out their documentation. To learn how GraphQL works checkout the official documentation, HowToGraphQL and this YouTube playlist (although it may be a bit outdated by now, better check the documentation).\nNodes # One of the most common ways to query data from the blockchain is by calling RPC endpoints of nodes that are syncing the full-state of the blockchain. A node runs the Ethereum blockchain, has all of its state, and syncs periodically every single time a new block appears. You can run your own node on consumer hardware, but it is unscalable if you want to use those nodes for querying data for massive applications as you\u0026rsquo;d need to build your own DevOps pipelines in order to scale to your needs accordingly. That\u0026rsquo;s why most developers use a third-party node provider like Alchemy or Infura. You can call these APIs by using web3 libraries like ethers.js, web3.js or myriad others. If you have a React front end, I strongly recommend using eth-hooks (can be installed as an npm package), which is built by the scaffold-eth people.\nMoralis # Moralis is a web3 development platform that automates your backend, instead of having to query data from nodes, indexing the data, and creating databases so that you don\u0026rsquo;t need to query the blockchain on every user request, Moralis does it for you. You instantiate a Moralis server that exposes an API to all blockchain data through a REST API to a PostgreSQL database. It also has smart contract alerts, cloud functions, cross-chain user authentication, and more. The only downside of using Moralis is that it\u0026rsquo;s a centralized service provider. It is the easiest way to get a backend for your Dapp going as Moralis has a very simple to use SDK that helps you tap into the APIs offered by their services. It is a great way to get started building backends as most of the heavy lifting is done for you.\nTo learn how to use Moralis checkout their documentation and their YouTube channel.\n"}).add({id:51,href:"/docs/back-end-development/oracles/",title:"Oracles",description:"How to tap into off-chain data and randomness via oracles.",content:"Oracles are data feeds that bring off-chain data on-chain so that the smart contracts that you build can query real-world information and build logic around it. For example, prediction market Dapps use oracles to settle payments based on events. A prediction market may ask you to bet your ETH on who will become the next president of the United States. They\u0026rsquo;ll use an oracle to confirm the outcome and payout to the winners.\n What is an oracle? - Chainlink  Chainlink is the most popular oracle out there, you\u0026rsquo;ll usually use it to get price feeds, to get verifiable randomness, to call external APIs, etc. If you want to get started building with Chainlink, go to their documentation.\nTo learn more visit the Ethereum.org page on oracles.\n"}).add({id:52,href:"/docs/back-end-development/did/",title:"DID",description:"Decentralized identity and user authentication.",content:"DID (decentralized identity) and web3 user authentication are a disruptive new primitive on the internet as we can be self-sovereign users of the internet and own our own value within it for the first time in human history. Usually, your user profile is managed by centralized service providers like Google, Facebook, Apple, Amazon, and others. In web3, the concept of a digital identity is much broader as it can span many more different areas such as financial history, games, social interaction (decentralized social media, i.e. Lens Protocol), and much more. It is still not clear how web3 user management will look like a few years from now, but there are a few solutions that are being standardized and are emerging as potential winners.\nSpruceID # SpruceID is a decentralized identity toolkit that allows users to sign and verify W3v verifiable credentials which are configurable across many interfaces. Use cases cited in the SpruceID documentation include: Authenticity for NFT creators, decentralized backup or recovery of decentralized identity, decentralized on-boarding for private DeFi pools, decentralized app-hosting, and many more potential use cases in the future. In order to integrate the Spruce DID solutions visit their developer portal.\nSign-in with Ethereum # Sign-in with Ethereum is an initiative that came off EIP-4361 which set off to standardize how Ethereum accounts interact and authenticate with off-chain services by signing a standard message format parameterized by scope, session details, and security mechanisms (e.g., a nonce). The goals of this specification are to provide a self-custodied alternative to centralized identity providers, improve interoperability across off-chain services for Ethereum-based authentication, and provide wallet vendors a consistent machine-readable message format to achieve improved user experiences and consent management.\nMany application builders have already adopted this signature standard for building applications on Ethereum as it streamlines the process for everyone and makes it more seamless for users since they have easily readable signatures from EIP-191. The aim of this EIP specification is to create a login standard similar to how web2 login with Google and Facebook became catalysts for adoption.\n"}).add({id:53,href:"/docs/back-end-development/automation/",title:"Automation",description:"How to automate tasks in your smart contracts.",content:"Within blockchain applications there are many actions that are repetitive and cumbersome to execute, for example, having to change the liquidity provision ranges inside of an active Uniswap v3 liquidity provision strategy, claiming rewards from yield vaults, and many other actions that users would like to automate so as to not have to deal with manual execution overhead.\nGelato network # Gelato Network is an automation protocol that runs as a decentralized network of bots used by web3 developers to automate smart contract executions on public EVM compatible blockchains including Ethereum, Polygon, Fantom, Arbitrum, Binance Smart Chain, and Avalanche.\nIn order to get started automating tasks inside of your application check out the official Gelato documentation which has tutorials on how to set up bots to regularly execute any given task in exchange for a small transaction fee. The setup inside of the contract function that you want bots to run would look something like this:\n   "}).add({id:54,href:"/docs/back-end-development/apis/",title:"Miscellaneous APIs",description:"Different APIs you might use throughout your blockchain development journey",content:"When building applications you will want to display miscellaneous information from various different other applications or protocols, e.g. price feeds for different tokens on different AMMs, the price of NFTs listed on different marketplaces, various data from services your application relies on, etc. As a backend developer, your responsibilities are to know where you can find reliable sources of data for your application and build the infrastructure needed to fetch it so that frontend developers can display it on the site. It is also important to build redundancy of the data you query and store it in your own databases in order to prevent your application from failing in the case of API dependency failure.\nOpenSea # A good example of such an API is OpenSea’s API which is public and can be queried in order to get the prices of NFT listings OpenSea, get floor prices, volumes, a bunch of other prices historical data, NFT metadata, and more.\nAs a developer, you can also create your own databases and API endpoints to fetch data from those databases. It is also a good way to earn revenue, by creating SaaS services around API keys with rate limits for how much data anyone can query off your servers. For building APIs you can for example use a REST API infrastructure with NodeJS and PostgreSQL, or for example, you can write a TheGraph subgraph.\n"}).add({id:55,href:"/docs/smart-contract-development/introduction/",title:"Introduction",description:"What is smart contract development and how to get started?",content:"Writing decentralized applications (Dapps) requires knowing how to write smart contracts as they are pieces of code that live on blockchains that can be executed inside of virtual machines. To write contracts you need to learn the programming languages that are able to compile to a target that the virtual machine can understand. In the case of the Ethereum blockchain, we have the EVM which has a set of operations it supports (a.k.a OPCODES). The most popular language for writing smart contracts on Ethereum is Solidity, which is a statically typed, object-oriented high-level programming language that takes inspiration from C++, Python, and JavaScript. With Solidity, you can program logic that executes inside of the EVM and the result of its operations is stored on the blockchain forever. The state of these applications is easily accessible from a full-node or from a third-party data indexing platform. The goal of smart contract developers is to create secure applications which perform a certain action, for example, a contract that allows for users to swap tokens, to buy and sell NFTs, to vote on proposals, etc.\nThere are many different stages in the smart contract development stage, from experimentation, iteration, testing, auditing, testnet deployment, and mainnet deployments. There are also different sets of best practices that developers and production teams adopt in order to mitigate the security and economic risk of their applications. Another important part of writing smart contracts on Ethereum or Ethereum L2s is optimizing the contracts to minimize the amount of gas they consume. Since block space on Ethereum and L2s is limited, there needs to be a fee mechanism in order to avoid state bloat that gives a fixed gas price to each operation executed by the respective VM. That means that the more complex a smart contract is, the more expensive it will be to deploy and for the users to use. There are various design patterns that optimize the code to consume the least amount of gas possible, whilst remaining readable and secure.\n"}).add({id:56,href:"/docs/smart-contract-development/solidity/",title:"Solidity",description:"How to write smart contracts in Solidity?",content:"Solidity is by far the most popular language to write smart contracts at the moment as the EVM is the most widely adopted virtual machine out there. Not only is it used in Ethereum\u0026rsquo;s execution layer, but many alt L1s and L2s on Ethereum use the EVM as their virtual machine since there\u0026rsquo;s a fairly mature development ecosystem. In order to first learn Solidity, we\u0026rsquo;ll go over a few simple courses that explain the principles of the language, and as we progress further we will talk about design patterns, testing, security, oracles, and more.\nCryptoZombies is an interactive web application that teaches you the basics of Solidity through a fun development game. It teaches you how to create a contract, the data types that Solidity supports, how to write methods, how to manage objects, events, inheritance, memory management, interfaces, modifiers, and more. By the time you finish the first three short courses, you\u0026rsquo;ll be able to read and write Solidity code. An alternative to CryptoZombies which is in video form is the Solidity playlist from Smart Contract Programmer on YouTube. This one is a bit better as it covers Solidity 0.8.0 which is a fairly recent version. Also go through the Solidity-by-example smart contracts which teach you the basics of Solidity, some common security vulnerabilities and the implementations of some popular patterns.\nAfter we finish the course with the basics, we\u0026rsquo;ll move on to building small projects implementing various different protocols, applications, and cryptographic primitives through the use of the scaffold-eth challenge that appear in this thread. Scaffold-eth is a web3 development template built by Austin Griffith and open-source contributors which abstracts the backend of your app and creates a front-end interface for interacting with the smart contracts that you write. We will start with the Ethereum Speed Run challenges in the thread mentioned above, and continue with building more complex applications like a signature-based multisig, an app that uploads images to IPFS, and more.\nNow that you\u0026rsquo;ve been writing more and more complex smart contracts it is a good idea to start looking at other people\u0026rsquo;s code to get a feel for how they implement different features, how they structure code, what designs and patterns they use, how they optimize for gas, and a lot more.\nThere are many techniques that you\u0026rsquo;ll be picking up along on your journey in order to make your contracts more resource-effective and gas-optimized so that your users don\u0026rsquo;t need to spend as much money for using your applications.\nA good example of well-made smart contracts at the intermediate level are Miguel Piedrafita\u0026rsquo;s lil-web3 contracts. They are simple implementations of popular protocols and applications. They also have tests attached to them which are written using Foundry, which we will cover shortly. Take a look at how comments are written, how events and errors are used, how it is structured, gas minimization techniques he employs, try to understand the design of the protocol implementation, etc. Trying to implement your own versions of well-known applications and protocols is a great way to improve at Solidity as you\u0026rsquo;ll learn a lot about the development process that you\u0026rsquo;ll go through once you are writing production code at a company or DAO.\nThreads that talk about getting really good at Solidity #  Tips from Emilio Frangella @ Aave Tips from @freddycoen Tips for non-beginners from @0xCacti Tips from @transmissions11 Tips from @Zer0dots  Once you\u0026rsquo;ve gone through all of the above the best you can do to learn Advanced Solidity is to see what the best codebases look like. Look at how they structure their projects, what gas optimizations they use, what Solidity patterns they employ, how they do tests, how they create interfaces, how they handle events and errors, what libraries/dependencies do they use (if any), etc.\nExamples of great codebases: #  Uniswap v2 / Uniswap v3 Gnosis Safe Compound finance Zora v3 Rari Capital Ribbon Finance  "}).add({id:57,href:"/docs/smart-contract-development/oracles/",title:"Oracles",description:"How to tap into off-chain data and randomness via oracles.",content:"Oracles are data feeds that bring off-chain data on-chain so that the smart contracts that you build can query real-world information and build logic around it. For example, prediction market Dapps use oracles to settle payments based on events. A prediction market may ask you to bet your ETH on who will become the next president of the United States. They\u0026rsquo;ll use an oracle to confirm the outcome and payout to the winners.\n What is an oracle? - Chainlink  Chainlink is the most popular oracle out there, you\u0026rsquo;ll usually use it to get price feeds, to get verifiable randomness, to call external APIs, etc. If you want to get started building with Chainlink, go to their documentation.\nTo learn more visit the Ethereum.org page on oracles.\n"}).add({id:58,href:"/docs/smart-contract-development/testing/",title:"Testing",description:"How to test smart contracts",content:"Testing smart contracts is an essential part of the development process as it ensures that the code you write behaves as intended and is secure against various technical and economic exploits. Many different libraries are used by different teams, there are pros and cons to using each different library and in some cases, they can be used in a complementary fashion. We will cover the most popular ones among top-tier developers as well as the most commonly used ones like HardHat and Truffle.\nOpinionated recommendations: Foundry for testing and Hardhat for deployments\nFoundry # Foundry is the hottest library in the Ethereum development landscape, it is originally built by Georgios Konstantopoulos who is one of the most highly respected developers in the entire Ethereum ecosystem. Georgios is currently the CTO at Paradigm and part of his job is building tools for developers that will be used to create the applications of the future.\nFoundry is composed of two parts: Forge and Cast.\n Forge: Forge is a fast and flexible Ethereum testing framework, inspired by Dapptools. Cast: Swiss army knife for interacting with EVM smart contracts, sending transactions, and getting chain data.  The library is written in Rust, which is a systems-level programming language that has memory safety, borrow checking, performant concurrency, and many other features which are making it one of the favorite languages used by developers across all fronts. Many popular libraries are being written in Rust, popular compiler targets like WASM are supported by Rust, a lot of Ethereum developer tooling is built using Rust or is refactoring their infrastructure to use Rust. It is a very exciting trend in blockchain development and many developers are learning the language to be able to contribute to these cool pieces of software. The best way to get started with Rust is The Rust Book and the Rustlings repo.\nThe reason why Foundry is getting a lot of popularity and it is so important, is because Solidity tests should be written in Solidity and not in JavaScript. It is very hard to master two different languages at once and Solidity developers shouldn\u0026rsquo;t be forced to learn it in order to be able to test their smart contracts. Foundry is also getting an increasingly superior development environment in terms of features. The main features for which you might use other toolkits are mainly deployment which is not supported by Foundry so far. For managing deployments, the standard toolkit is HardHat. For testing, gas optimization features, fuzzing, symbolic execution (hevm), etc, do use Foundry. Good resources for learning and mastering Foundry are:\n The Foundry Book - Community sourced documentation Tweet from @andreasbigger:  Familiarize yourself w/ Forge-cli Checkout some templates:  FrankieIsLost forge template ZeframLou forge template AndreasBigger femplate   Dive into repos using Foundry:  lil-web3 n3rp zen cloaks ethernaut-x-foundry damn-vulnerable-defi-foundry Multicall   Brockelmore\u0026rsquo;s testing verbosity with forge-std    HardHat # Hardhat is the Ethereum development library that’s the most widely used across the ecosystem and is the standard in most production codebases like Aave, Uniswap, and many others. Usually, all the deploy scripts, migration files, automation scripts, etc are written using Hardhat and their tooling suite. It is a javascript library (that has Typescript support). Recently the Hardhat team announced that they are moving their infrastructure to Rust as most of the tooling ecosystem is moving to use it do its performance and security.\nDapptools # Dapptools is a suite of Ethereum focused CLI tools following the Unix design philosophy, favoring composability, configurability, and extensibility.\nThere are 4 key elements in Dapptools:\n dapp - All you need Ethereum development tool. Build, test, fuzz, formally verify, debug \u0026amp; deploy solidity contracts. seth - Ethereum CLI. Query contracts, send transactions, follow logs, slice \u0026amp; dice data. hevm - Testing-oriented EVM implementation. Debug, fuzz, or symbolically execute code against local or mainnet state. ethsign - Sign Ethereum transactions from a local Keystore or hardware wallet.  A cool innovation done by app tools was the hEVM which is an EVM implementation written in Haskell (a functional programming language) that allows to symbolically execute Solidity code and formally verify the results of the resulting bytecode (opcode operations). This feature was later adopted by Foundry, including many others that were first provided by Dapptools.\nTruffle Suite # Truffle Suite is a suite of tools developed by Consensys to locally test smart contracts by deploying them on a local instance of the Ethereum blockchain, mocking user addresses using the Ganache library, writing tests using Truffle, and creating on-chain data pipelines for user interfaces using Drizzle. It was one of the first complete Ethereum developer tooling ecosystems that were released, but they’ve fallen out of favor in recent years as libraries like Hardhat overtook it.\n"}).add({id:59,href:"/docs/smart-contract-development/design-patterns/",title:"Design patterns",description:"Modern Solidity application design patterns",content:"Once you\u0026rsquo;re comfortable with writing more and more complex contracts and maybe taking a look at the front-end code and it interacts with the smart contracts, you\u0026rsquo;ll start getting a feel for how smart contracts are designed from a more high-level view. There are certain designs and patterns which are commonplace, things like the approved pattern for tokens, and more. At this point, it is a good idea to start thinking more about the overall architecture of your code and the structure that it will take to efficiently implement the functionality you want to enable.\nThere are common patterns employed in smart contract development, this Solidty-patterns repo implements some of them.\nSince the EVM is such a constrained environment where each additional operation executed by the EVM adds gas costs to the execution of the smart contract, developers try to build as least resource-intensive contracts as possible whilst also maximizing readability and security. Since blockchains are a very adversarial environment were mistakes in a smart contract could lead to fund drains (RUGS) and exploits, it can be considered mission-critical software and so many developers get inspiration from other mission-critical software guidelines like the ones of NASA which are responsible for the lives of astronauts going to space. These development principles are guidelines that help optimize a codebase for maximum security through the adoption of a standardized procedure and developer mindset.\nENS integration # We mentioned how to integrate ENS domain names into your dapp within the front end development section, but as a smart contract developer you can also resolve ENS domain names on-chain, write your own resolver which implements EIP137 or even write your own registrar.\n"}).add({id:60,href:"/docs/smart-contract-development/specialized-languages/",title:"Specialized languages",description:"Languages to write lower lever EVM compatible bytecode",content:"There are various programming languages that can be compiled into EVM bytecode, there are high-level programming languages such as Solidity, Vyper, or Fe, but there\u0026rsquo;s also an intermediate programming language that\u0026rsquo;s often used within gas-optimized contracts called Yul, or as a developer, you can write EVM assembly by writing the EVM opcodes directly. A common technique for gas minimization is writing Solidity code looking at the resulting EVM assembly code and comparing the gas cost of different implementations in order to make the contract as gas-efficient as possible.\nYul # Yul is an intermediate-level programming language that can compile into EVM bytecode. From the Solidity documentation:\n\u0026ldquo;The design of Yul tries to achieve several goals:\n  Programs written in Yul should be readable, even if the code is generated by a compiler from Solidity or another high-level language.\n  Control flow should be easy to understand to help in manual inspection, formal verification, and optimization.\n  The translation from Yul to bytecode should be as straightforward as possible.\n  Yul should be suitable for whole-program optimization.\n  In order to achieve the first and second goals, Yul provides high-level constructs like for loops, if and switch statements and function calls. These should be sufficient for adequately representing the control flow for assembly programs. Therefore, no explicit statements for SWAP, DUP, JUMPDEST, JUMP and JUMPI are provided, because the first two obfuscate the data flow and the last two obfuscate control flow. Furthermore, functional statements of the form mul(add(x, y), 7) are preferred over pure opcode statements like 7 y x add mul because, in the first form, it is much easier to see which operand is used for which opcode.\u0026rdquo;\nEVM Assembly # EVM Assembly can be written inside of inline Solidity statements with the assembly keyword. It allows for more fine-grained control over the resulting bytecode. Oftentimes the compiler is unable to optimize Solidity code well and so it results in unnecessary gas costs.\nThere\u0026rsquo;s also an unchecked keyword in Solidity which disables the overflow and underflow checks from the compiler which were introduced in Solidity 0.8.0 and before were part of the SafeMath library in OpenZeppelin libraries. The unchecked keyword is oftentimes used.\nWriting Yul or inline assembly can obfuscate the functionality of your code by making it less readable for other contributors/auditors and it can potentially introduce new risks as the Solidity compiler oftentimes performs various optimizations and security checks.\nGood toolkits for writing EVM Assembly:\n etk huffc and the afforementioned Yul intermediate language  "}).add({id:61,href:"/docs/smart-contract-development/evm-deep-dive/",title:"EVM deep dive",description:"Learn about the inner workings of the EVM.",content:"Understanding the ins and outs of the EVM is crucial for building highly optimized applications as each operation executed by the EVM has a gas cost attached to it and users have to pay the price for executing functions within the applications that they use. There is a compromise between readability and code optimizations however, which needs to be taken into consideration. Sometimes using techniques like bitshifting and bitmapping (Hacker\u0026rsquo;s Delight is a good book that talks about bit manipulation techniques in detail) can have a negative impact on readability and thus security, as other contributors and auditors may not be able to wrap their heads around these complex optimizations or it would simply take too much time for them to do so. For code that actually goes into production, each project needs to asses how much do they want to optimize their code for gas savings over readability. Security usually comes first, however there are still a set of well-known good practices that will allow you to save some gas. If you end up using gas optimization techniques it is also advised to document them well with comments inside of your Solidity contracts. Another important point is that as these technologies scale and developers are less constrained by the virtual machine executing smart contract bytecode, the needs for optimizations becomes less important along with the fact that the compilers converting static code to machine code are getting better and better at optimizing code for performance and low costs. As technologies like L2s and data availability layers become mainstream we also may see an emergence of new VM architectures that experiment with new designs that do not require developers to work with low-level optimizations as they will be highly performant and scalable.\nFor a comprehensive EVM deepdive, I suggest these resources:\n EVM development starter kit Read Chapter 13 (EVM) of The Ethereum Book Read Femboy Capital\u0026rsquo;s Playdate with the EVM Go over OpenZeppelin\u0026rsquo;s series on Deconstructing smart contracts Read Analyzing smart contracts by Elvira Albert (very math heavy) Read over TakeNobu\u0026rsquo;s slides on how the EVM works (visualized) Go over design patterns section Go over the exemplary good codebases at the beginning of the Solidity section Follow gas optimizoors like @transmission11 for gas alpha Get used to going to lookup gas costs for different OPCODE operations at EVM Codes Check out the EVM execution specs Learn to use Foundry well Bonus resources in comments of this Twitter thread  Special thanks to @0x_doggie and @freddycoen from whose threads I extrapolated these resources.\n Thread 1 Thread 2  You might wanna go through Nick\u0026rsquo;s Posts and Jean\u0026rsquo;s Solidity articles\n"}).add({id:62,href:"/docs/full-stack-development/introduction/",title:"Introduction",description:"What is full-stack blockchain development and how to get started",content:"As the name implies, full-stack blockchain development is the closest specialization to being a jack of all trades. It involves building out all of the aspects of an application from front end, to smart contracts, to backend (at least to a certain degree). This is the most generic role that most blockchain developers will take and most companies and DAOs are looking for in a contributor. Since there is such a high demand for quality developers in the space, it is oftentimes the case that employers onboard people from different fields and turn them into a jack of all trades within web3 development so as to save costs and reduce HR resource requirements (which are incredibly scarce nowadays).\nSince rewriting the front end, back end and smart contract sections would be pointless, I\u0026rsquo;ll dedicate this section just to list a bunch of full-stack guides, tips and tricks, deployment guidelines, project management, and other relevant information.\n"}).add({id:63,href:"/docs/full-stack-development/guides/",title:"Full-stack guides",description:"Guides that will teach you how to become a full-stack blockchain developer",content:"Guides that will help you become a full-stack blockchain developer:\n Open-source Computer Science Introduction to Ethereum Development - Austin Griffith The Complete Guide to Full Stack Web3 Development - Nader Dabit Speed Run Ethereum - Austin Griffith Solidity, Blockchain, and Smart Contracts Course - Beginner to Expert Python Tutorial - Patrick Collins Full-stack blockchain solidity course - Patrick Collins DeFi Developer Roadmap  "}).add({id:64,href:"/docs/full-stack-development/tutorials/",title:"Full-stack tutorials",description:"Tutorials that are related to full-stack blockchain development",content:"Tutorials that are related to full-stack blockchain development:\n Introduction to Ethereum Build Uniswap Blockchain Web3 App with Solidity | Next.js | Sanity.io  "}).add({id:65,href:"/docs/core-development/introduction/",title:"Introduction",description:"What is core development and what necessary knowledge do you need to contribute?",content:"This section was made possible thanks to @protolambda, he\u0026rsquo;s an Ethereum researcher and core dev who previously worked at the Ethereum foundation who now works for the Optimism Ethereum L2.\nThank you very much Proto for contributing your knowledge!\n"}).add({id:66,href:"/docs/core-development/general-learning/",title:"General learning",description:"What do you need to learn in order to learn core development",content:"There are many topics to learn about in core-development, one can specialize in any area. Here is a selection of learning-resources:\nBasic #  Merkle trees:  Ethereum execution-layer Merkle Patricia Tree walkthrough   Execution and Consensus layer Merge design, video by Danny Ryan Rollup centric roadmap, post by Vitalik Ethereum protocol ELI5 (coming soon)  Medium: #  Yellow Paper: L1 protocol specification in paper form ABI: Application Binary Interface to interact with contracts EVM opcodes: interactive reference RLP: the encoding used everywhere in execution-layer SSZ specs: encoding and merkleization of Eth2, also see visualized encoding and visualized hash-tree-root. EVM: overview of the machine that runs smart-contracts Executable specs: readability-first python implementations of the protocol specification.  Consensus-layer, also see pip package Execution-layer, also see the rendered version.   Simplified Eth2 Phase0 specs intro Light client design and implementation  Advanced: #  Builder proposer separation:  Proposer/block builder separation-friendly fee market designs Flashbots: frontrunning the MEV crisis state of research and   Fork-choice Gasper paper: Combining GHOST and Casper Dagger-Hashimoto (legacy PoW) State DB design, Erigon docs:  Choice of storage engine State representation   BLS:  Signature aggregation in eth2 by Justin Drake BLS12-381 For The Rest Of Us by Ben Edgington BLS Signature for Busy People by Paul Miller   KZG:  KZG polynomial commitments by Dankrad Feist ZK Study Club part 1: polynomial commitments by ZK FM podcast with Justin Drake   ZK:  ZK study club playlist by ZK FM podcast   Fraud proofs (optimistic rollup tech):  The State of Optimistic Rollup older overview by Daniel Goldman Inside Arbitrum arbitrum fraud proof Cannon optimism fraud proof   LibP2P: the network layer in Eth2, Polkadot, Filecoin and other blockchains. DevP2P: the original network layer in Eth1 / execution-layer of ethereum. Whisk: A practical shuffle-based SSLE protocol for Ethereum VDF research: verifiable delay function for ethereum and other protocols Data Availability Sampling (DAS):  DAS in practice DAS in full sharding design    "}).add({id:67,href:"/docs/core-development/l2/",title:"Layer 2",description:"How to work on layer 2 core development and what do you need to learn?",content:"Layer-2 scales Layer-1 by increasing capacity without significantly changing the security assumptions of the Layer-2. Although this does not change L1 itself, it does influence the general scaling design direction, generally pushing ethereum into a rollup-centric roadmap.\nDomains: #  Side-chains: EthHub, eth org State channels: EthHub, eth org Plasma (mostly deprecated): EthHub, eth org Rollups intro by Polynya  ZK rollups (ZKRUs): EthHub, eth org Optimistic rollups (ORUs): EthHub, eth org   Bridges: eth org intro L3 / validiums / volitations etc:  starkware L3 Validium eth org intro    Refer to L2beat.com for an overview of active L2 scaling solutions.\n"}).add({id:68,href:"/docs/core-development/l1/",title:"Layer 1",description:"How to work on layer 1 core development and what do you need to learn?",content:"Domains: #  Eth1 / execution layer  Networking: devp2p EVM Tx pool Sync methods (Fast, Snap, Archive, Beam, Light) State DB User-facing (JSON RPC, tx tracing, etc.)   Eth2 / consensus layer  Networking: libp2p Fork-choice Attestations / BLS aggregation Staking / Validator clients Slashings Sharding    "}).add({id:69,href:"/docs/core-development/news/",title:"News",description:"Where to look for Ethereum news?",content:"Selection of protocol news resources: #  Week in Ethereum: OG weekly news letter Eth2.News: eth2 news by Ben Edgington harding Ethereum cat herders: Channel discussing changes in core dev calls and EIP specifications Ethereum foundation: YouTube channel where Ethereum core dev calls are hosted after they are done Ethereum/pm: This repository is used for project management for various initiatives affecting the Ethereum protocol. The main use of this repository is for the All Core Devs meeting, but it is also used for Ethereum 1.x, Merge and Fee Market meetings. Tim Beiko\u0026rsquo;s Twtter  "}).add({id:70,href:"/docs/core-development/communication/",title:"Communications",description:"Where all the chatter takes place",content:"Most relevant communication channels #  Discord Eth R\u0026amp;D server Eth magicians, forum for governance / protocol discussion Eth research, forum for research discussion AllCoreDevs (ACD): discord channel in R\u0026amp;D Ethereum Foundation youtube channel (streams ACD and Consensus calls)  "}).add({id:71,href:"/docs/core-development/core-teams/",title:"Ethereum core teams",description:"Client teams that work on Ethereum and consensus layers",content:"Eth1 - execution layer Eth2 - consensus layer (nomenclature recently depreciated, but still used in some contexts)\nClient teams (those that are open-source), in no particular order:\n   Domain Project Language Discord Docs     Eth2 Prysm Go invite docs   Eth2 Lighthouse Rust invite docs   Eth2 Lodestar Typescript invite docs   Eth1 + Eth2 Nimbus eth2 and eth1 Nim invite docs   Eth2 Teku (Artemis + Harmony) Java / Kotlin invite docs   Eth1 Go-ethereum Go invite docs   Eth1 Nethermind C# invite docs   Eth1 Besu Java invite docs   Eth1 ethereum-JS Javascript invite docs   Eth1 Erigon Go Invite-only docs    "}).add({id:72,href:"/docs/core-development/l1-specifications/",title:"L1 specifications",description:"Specs for the L1 consensus and execution layers",content:"Consensus layer #  Consensus specs Beacon APIs, also see interactive site Annotated specs by Vitalik Buterin Eth2 book: extended annotated specs with some eth2 history, by Ben Edgington Legacy (but good) resources:  Proof Of Stake F.A.Q. Sharding F.A.Q. Ethereum sharding research compendium    Execution layer #  Ethereum Improvement Proposals: EIPs Execution APIs New Execution py-specs  "}).add({id:73,href:"/docs/blockchain-data-analysis/resources/",title:"Resources",description:"A few resources to learn blockchain data analysis",content:"Section is undergoing planning, and searching for a champion/spearheader for the creation of it. Useful links in the meantime:\n learn-python Dune analytics guide awesome-datascience awesome-python-data-science Python for data science  "}).add({id:74,href:"/docs/blockchain-data-analysis/coming-soon/",title:"Coming soon",description:"Coming soon",content:"This section is in the process of planning by popular demand. It is not actively being developed and does not have a champion (person spearheading the development).\n"}).add({id:75,href:"/docs/protocol-development/coming-soon/",title:"Coming soon",description:"Coming soon",content:"This section is in the process of planning by popular demand. It is not actively being developed and does not have a champion (person spearheading the development).\n"}).add({id:76,href:"/docs/getting-a-job/introduction/",title:"Introduction",description:"How to get a job in blockchain development, crypto and web3 at large",content:"Once you start having a solid foundational skillset within blockchain development you can start looking for junior positions in your area of interest. One of the best parts of web3 is that many projects have open-source codebases which make it much easier to contribute to. There are various structures in web3 that allow a developer to get paid for their work, some of them are:\n working for a company that is building a web3 product setting up a grant through Gitcoin Getting bounties by working for DAOs find vulnerabilities in applications, protocols and contracts for security bounties through platforms like ImmuneFi being a DAO core contributor and getting paid with bounties  The easiest way to find a job is being active in the social platforms of the projects you\u0026rsquo;d like to be hired at or contribute to, e.g. if you want to become a smart contract developer at Uniswap, then talk to the team on Discord, suggest them new features, implement mockups, apply for a grant and if you are good enough someone will notice and try to hire you to work on it full-time within the DAO itself or for Uniswap Labs which is the core team leading the smart contract development efforts. The most important thing is to show initiative, being proactive and openly talking about helping. If you come across something interesting also don\u0026rsquo;t forget to post it on Twitter or on Telegram.\nIn order to find interesting projects to work for, web3 devs look at Twitter as it\u0026rsquo;s the place where everything unfolds and where every single project lives. If you build out a reputation as a good blockchain developer, then you\u0026rsquo;ll start getting DMs from interesting people and projects as there is an extreme lack of talent in the space and insatiable demand for good developers.\n"}).add({id:77,href:"/docs/getting-a-job/portfolio/",title:"Porfolio",description:"How to create a portfolio of relevant projects in the blockchain space",content:"In order to become a good job candidate, it is almost imperative to have a portfolio of projects that you\u0026rsquo;ve built in order to showcase the skills you have, the technologies you use and your thought processes behind solving different problems. I.e. if you are interested in building DeFi applications then you can showcase that by writing a demo of an AMM, a yield aggregator, a money market, etc. The more high quality demo projects you have the better as these will act as valuable information for teams looking to hire. The most popular way to showcase your projects is to publish them publicly on GitHub.\nIf you don\u0026rsquo;t know what to build you can look at different problems different projects are facing, try solving one of them and publishing the solution as a public repo on GitHub. You can build demo projects from sites like SpeedRunEthereum using templates like scaffold-eth, and much more.\n"}).add({id:78,href:"/docs/getting-a-job/job-boards/",title:"Job boards",description:"The most popular aggregators of open job positions in crypto and web3",content:"The two most used platforms to find crypto/web3 jobs are Twitter and a few select job boards. The main job boards used by recruiters and workers are:\n crypto.jobs cryptojobslist.com bankless job pallet web3 career cryptocurrencyjobs web3 pallet useweb3 jobs web3 board defi jobs  "}).add({id:79,href:"/docs/getting-a-job/twitter/",title:"Twitter",description:"How to leverage the Twitter social network in order to get a job in crypto/web3",content:"Twitter is the place to find a blockchain development job, LinkedIn is rarely used for hiring talent in the space, although it\u0026rsquo;s not too uncommon either. As most of the web3/crypto culture resides on Twitter, it is a natural place for developers, founders, creators and users to hangout together. The more value you provide to the community, the more following you\u0026rsquo;ll get, therefore the more outreach as a developer. All teams are thirsty for good developers and so the more relevant followers you have, the more chances you\u0026rsquo;ll get of being discovered by a team looking to hire a blockchain developer in your field of expertise. Building up your Twitter reputation can propel you forwards more than you\u0026rsquo;d expect, a lot of friendships, partnerships and collaborations have been initiated through Twitter and it is currently the place to account for social value (clout) in the space.\nIf you manage to demonstrate mastery of any given skill within web3, then you are guaranteed a position pretty much anywhere as all teams are looking for talent. If you are just starting out, but you show a strong drive and initiative to learn then many teams will ask to take you under their wing in order to upscale your skills by getting your hands dirty and learning while building as you go. By being active on relevant social platforms like Twitter, Discord and Telegram and socializing with the right people, finding a job becomes relatively easy as everyone is looking to hire talent.\n"}).add({id:80,href:"/docs/coming-soon/",title:"Coming soon",description:"Coming soon",content:"This section is in the process of planning by popular demand. It is not actively being developed and does not have a champion (person spearheading the development).\n"}).add({id:81,href:"/docs/cryptography/wip/",title:"WIP",description:"Work in Progress",content:"This section is actively being developed and has a champion (person spearheading the development).\n"}).add({id:82,href:"/docs/defi-development/wip/",title:"WIP",description:"Work in Progress",content:"This section is actively being developed and has a champion (person spearheading the development).\n"}).add({id:83,href:"/docs/mastery/wip/",title:"WIP",description:"Work in Progress",content:"This section is actively being developed and has a champion (person spearheading the development).\n"}).add({id:84,href:"/docs/mev-searcher/wip/",title:"WIP",description:"Work in Progress",content:"This section is actively being developed and has a champion (person spearheading the development).\n"}).add({id:85,href:"/docs/security-engineer/wip/",title:"WIP",description:"Work in Progress",content:"This section is actively being developed and has a champion (person spearheading the development).\n"}).add({id:86,href:"/docs/social-capital/wip/",title:"WIP",description:"Work in Progress",content:"This section is actively being developed and has a champion (person spearheading the development).\n"}).add({id:87,href:"/docs/starknet-development/wip/",title:"WIP",description:"Work in Progress",content:"   This section is actively being developed and has a champion (person spearheading the development).\nDevelopment of this section is done in partnership with Starkware and developers from the Starknet ecosystem.\n"}).add({id:88,href:"/docs/wip/",title:"WIP",description:"Work in Progress",content:"This section is actively being developed and has a champion (person spearheading the development).\n"}).add({id:89,href:"/docs/",title:"devpill.me",description:"devpill.me",content:""}),search.addEventListener('input',b,!0);function b(){var b,e;const d=5;b=this.value,e=a.search(b,{limit:d,enrich:!0});const c=new Map;for(const a of e.flatMap(a=>a.result)){if(c.has(a.doc.href))continue;c.set(a.doc.href,a.doc)}if(suggestions.innerHTML="",suggestions.classList.remove('d-none'),c.size===0&&b){const a=document.createElement('div');a.innerHTML=`No results for "<strong>${b}</strong>"`,a.classList.add("suggestion__no-results"),suggestions.appendChild(a);return}for(const[h,g]of c){const b=document.createElement('div');suggestions.appendChild(b);const a=document.createElement('a');a.href=h,b.appendChild(a);const e=document.createElement('span');e.textContent=g.title,e.classList.add("suggestion__title"),a.appendChild(e);const f=document.createElement('span');if(f.textContent=g.description,f.classList.add("suggestion__description"),a.appendChild(f),suggestions.appendChild(b),suggestions.childElementCount==d)break}}})()